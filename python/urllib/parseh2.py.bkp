import urllib.request, re

def getHtml(url, isFile=False):
    # Obtiene una string de una url o archivo.
    if isFile:
        try:
            with open(url, 'r', encoding='utf-8') as f:
                html = f.read()
        except:
            with open(url, 'r', encoding='latin-1') as f:
                html = f.read()
    else:
        if(not re.match(r'https?://', url)):
            url = 'http://' + url
            response = urllib.request.urlopen(url)
            htmlBytes = response.read()
            try:
                html = htmlBytes.decode('utf-8')
            except:
                html = htmlBytes.decode('latin-1')
    return(html)

def parse1(html):
    # obtiene pares que delimitan una string.
    ctr=0
    pares = []
    desde = 0
    str0 = False
    str1 = False
    script = False
    for i in range(len(html)):
        c = html[i]
        if not str0 and c is '\'': str0 = True
        if not str1 and c is '"': str1 = True
        if str0 and c is '\'' and html[i-1] is not '\\': str0 = False
        if str1 and c is '"' and html[i-1] is not '\\': str1 = False
        if not desde: desde = i
        if str0 or str1: continue
        ## aca empieza
        if c is '<' and html[i + 1] is not ' ':
            if script:
                if not re.match('</script',html[i:i+8],re.I): continue
                else:
                    script = False
                    continue
            # elemento en nivel = 0:
            if not ctr:
                hasta = i
                if desde < hasta: pares.append([desde, hasta])
                # marco inicio de elemento:
                desde = i
            ctr += 1
            if re.match('<script', html[i:i+7],re.I): script = True
        if c is '>' and not script:# and html[i - 1] is not ' ':
            if not ctr: continue
            ctr -= 1
            # cierra un elemento:
            if not ctr:
                # marco  fin de elemento.
#                desde = i + 1
                hasta = i + 1
                # lo que sigue podria mejorarse quiza, es para
                # agrego bordes de elemento a la lista.
                pares.append([desde, hasta])
                desde = i + 1
    return pares

def substr(string, pares):
    # devuelve una pagina, en estado 'atomico'
    return [string[par[0]:par[1]] for par in pares]

        
def getpag(url):
    g = getHtml(url,1)
    p = parse1(g)
    s = substr(g,p)
    return s

g = getpag('html1')

print('''
funciones definidas:
getHtml(url, isFile=0)
parse1(html)
substr(string, pares)

g = getpag(url):
''')

def agrupar(pag, fstIndx=0):
    desde = 0
    pares = []
    currentTag = ''
    ctr = 0 # es necesario??
    for i in range(len(pag)):
        match = re.match('<([^ >]+)',pag[i])
        if not match:
            if not currentTag: pares.append(i + fstIndx)
            continue
        # Hubo match.
        m = match.group(1)
        if m[0] is not '/':
            # Es beggining.
            if not currentTag:
                currentTag = m
                desde = i
                ctr += 1
            continue
        # En end.
        if m == "/%s" % currentTag:
            ctr -= 1
            if ctr == 0:
                hasta = i
                #recursive = agrupar(pag[desde+1:hasta-1], desde + 2)
                #recursive[0:0] = [desde + fstIndx]
                #recursive.append(hasta + fstIndx + 1)
                #pares.append(recursive)
                pares.append([desde + fstIndx, hasta + fstIndx])
                currentTag = ''
    return pares

